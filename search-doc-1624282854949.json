[{"title":"Adding Environments","type":0,"sectionRef":"#","url":"cra/advanced/adding-environments","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"React","type":0,"sectionRef":"#","url":"cra/","content":"","keywords":""},{"title":"Create React App","type":1,"pageTitle":"React","url":"cra/#create-react-app","content":"Create React App is the main part of the development environment, these docs only covers the Intility templates for it. This means that everything from the official Create React App docs applies to your project. If you can't find what your looking for here, check the CRA docs. "},{"title":"Recommended reading","type":1,"pageTitle":"React","url":"cra/#recommended-reading","content":"Environment VariablesAdvanced ConfigurationCode Splitting "},{"title":"ADFS Authentication","type":0,"sectionRef":"#","url":"cra/advanced/adfs","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"Deploy with ArgoCD","type":0,"sectionRef":"#","url":"cra/advanced/deploy-argocd","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"Deploy to Azure","type":0,"sectionRef":"#","url":"cra/advanced/deploy-azure","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"Upgrade to V1 pipeline","type":0,"sectionRef":"#","url":"cra/advanced/upgrade-pipeline","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"Upgrade to V1 pipeline","url":"cra/advanced/upgrade-pipeline#features","content":"Helm chartDocker image pushed to GCRParallelized jobs (pipeline usually takes ~2m) "},{"title":"OpenShift","type":1,"pageTitle":"Upgrade to V1 pipeline","url":"cra/advanced/upgrade-pipeline#openshift","content":"When switching to the new pipeline, it will automatically create new resources. At a minimum, you should delete the existing route, as the old one will crash with the new one. However, it's recommended to start blank, by either clearing out or re-creating the existing project, or by creating a new project. "},{"title":"Create Deploy Token","type":1,"pageTitle":"Upgrade to V1 pipeline","url":"cra/advanced/upgrade-pipeline#create-deploy-token","content":"The new pipeline publishes a docker image to GitLab Container Registry, and uses Helm to create resources in OpenShift. As a result, OpenShift needs access to pull images from GCR. In your GitLab repository, go to Settings -> Repository -> Deploy tokens. Create a new token named gitlab-deploy-token, and give it the read_registry scope.  That's all you have to do in the repository. The token is exposed as a variable in the pipeline, and helm applies it as a pull secret in OpenShift. Read more about GitLab deploy tokens here. "},{"title":"Edit index.ts","type":1,"pageTitle":"Upgrade to V1 pipeline","url":"cra/advanced/upgrade-pipeline#edit-indexts","content":"The new pipeline doesn't use a REACT_APP_REDIRECT_URI environment variable in the pipeline, so we need to change auth.redirectUri in our MSAL Config. index.ts const msal ={ auth:{ // This is the new value of redirectUri redirectUri:window.location.origin } }; Copy "},{"title":"Copy files","type":1,"pageTitle":"Upgrade to V1 pipeline","url":"cra/advanced/upgrade-pipeline#copy-files","content":"Download the contents of this repository (direct zip download). Copy all files except README.md to your project, and push the changes. The new pipeline should now take effect. Should any problems occur, ask a question in #programming on Slack. "},{"title":"Deploy","type":0,"sectionRef":"#","url":"cra/configuration/deploy","content":"","keywords":""},{"title":"Create project","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#create-project","content":""},{"title":"UI","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#ui","content":"Go to our OpenShift instance and log in as Intility Developer. Create a project, the name should be aa-<GITLAB_SLUG>-dev, e.g. aa-my-app-dev. If you use something other than this, you'll need to modify the OPENSHIFT_PROJECT variable in the top of the .gitlab-ci.yml file. Add a fitting display name and description if you feel like it. "},{"title":"CLI","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#cli","content":"The name should be aa-<GITLAB_SLUG>-dev, e.g. aa-my-app-dev. If you use something other than this, you'll need to modify the OPENSHIFT_PROJECT variable in the top of the .gitlab-ci.yml file. oc new-project <projectname> Copy "},{"title":"Acquire Token","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#acquire-token","content":""},{"title":"UI","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#ui-1","content":"In your newly created project, switch from Developer to Administrator view in the sidebar. Then go to User Management -> Service Accounts, and click Create Service Account. Change the name field to gitlab-builder.  After creating the Service Account, go to User Mangement -> Role Bindings, and click Create Binding. Fill the form with the following values: Role Binding Name: gitlab-builder-edit Role Name: edit Subject: Service Account Subject Name: gitlab-builder  After creating the role binding, go back to Service Accounts and go to the gitlab-builder Service Account. At the bottom of page, you'll find a link to a secret named gitlab-builder-token-*, click it. Copy the token field at the bottom of the page, and add it to GitLab CI/CD variables with the key OPENSHIFT_TOKEN. "},{"title":"CLI","type":1,"pageTitle":"Deploy","url":"cra/configuration/deploy#cli-1","content":"Copy login command from OpenShift Console and paste it in a terminal. After logging in, the CLI will show you available projects. Follow the instructions to change to the project you just created. When you have selected the right project, we need to create a Service Account. oc create sa gitlab-builder oc describe sa gitlab-builder Copy Note the gitlab-builder-token-* in the Mountable secrets section. Then we have to set the user to admin. oc policy add-role-to-user edit -z gitlab-builder Copy Lastly, we have to extract the token from the secret presented in the first step. oc describe secret <secret-name> Copy Copy the contents from the token section and add it to GitLab CI/CD variables with the key OPENSHIFT_TOKEN. "},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"cra/configuration/environment-variables","content":"Your project can consume variables declared in your environment as if they were declared locally in your JS files. By default you will have NODE_ENV defined for you, and any other environment variables starting with REACT_APP_. By default, .env.development is included, which will be loaded when you run your app locally. For more information, please read the Environment Variables section of the Create React App docs.","keywords":""},{"title":"GitLab Repository","type":0,"sectionRef":"#","url":"cra/configuration/gitlab","content":"","keywords":""},{"title":"Pushing your application","type":1,"pageTitle":"GitLab Repository","url":"cra/configuration/gitlab#pushing-your-application","content":"Create React App creates a git repository for you locally, but you'll have to add the GitLab repository as a remote. Copy the last three lines of the \"Push an existing Git repository\" example. They should look something like this: git remote add origin git@gitlab.intility.no:Group/intility-app.git git push -u origin --all git push -u origin --tags Copy The pipeline will fail initially, but don't worry, we'll set it up correctly in the next steps. "},{"title":"Add GitLab Deploy Token","type":1,"pageTitle":"GitLab Repository","url":"cra/configuration/gitlab#add-gitlab-deploy-token","content":"The pipeline publishes a docker image to GitLab Container Registry, and uses Helm to create resources in OpenShift. As a result, OpenShift needs access to pull images from GCR. In your GitLab repository, go to Settings -> Repository -> Deploy tokens. Create a new token named gitlab-deploy-token, and give it the read_registry scope.  That's all you have to do in the repository. The token is exposed as a variable in the pipeline, and helm applies it as a pull secret in OpenShift. Read more about GitLab deploy tokens here. "},{"title":"Adding CI/CD Variables","type":1,"pageTitle":"GitLab Repository","url":"cra/configuration/gitlab#adding-cicd-variables","content":"In your project on GitLab, go to Settings -> CI / CD, and expand the Variables section. We don't need to add anything yet, but it's here we'll add tokens and such in the other steps. "},{"title":"Adding Badges","type":1,"pageTitle":"GitLab Repository","url":"cra/configuration/gitlab#adding-badges","content":"In your project on GitLab, go to Settings -> General, and expand the Badges section. Here you can add badges by giving them a Name, Link and Image URL.  We can go ahead and add a badge for our pipeline with the following values: Name: Pipeline Link: https://gitlab.intility.com/%{project_path} Image URL: https://gitlab.intility.com/%{project_path}/badges/%{default_branch}/pipeline.svg "},{"title":".gitlab-ci.yml Overview","type":0,"sectionRef":"#","url":"cra/configuration/gitlab-ci","content":"","keywords":""},{"title":"build & build:dev","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#build--builddev","content":"The main build job runs npm run build on every push to all branches (except master). It will pass some default environment variables; REACT_APP_SENTRY_DSN will be SENTRY_ENVREACT_APP_SENTRY_ENVIRONMENT will be the git branch nameREACT_APP_SENTRY_RELEASE will be the git commit SHAREACT_APP_REDIRECT_URI will be https://{projectSlug}-{branchName}.openshift-inside.intility.no It also creates an artifact of the build folder that is created, which will be passed onto later jobs. The build:dev pipeline does the same as build, except it only runs on the master branch. We override two variables: REACT_APP_SENTRY_ENVIRONMENT and REACT_APP_REDIRECT_URI. We do that because we want our environment to be dev instead of master, and the redirect URI to be ...{projectSlug}... instead of ...{projectSlug}-master.... "},{"title":"test","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#test","content":"This job simply runs the npm test script. "},{"title":"sonarqube","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#sonarqube","content":"This job uses the SonarScanner CLI to upload the source code to SonarQube. The pipeline will continue if this job fails, but it should be looked into. "},{"title":"sentry","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#sentry","content":"The sentry job uses the Sentry CLI to create a new release. The release name will be the git commit SHA. It will connect the release to the current commit, and upload sourcemaps from the build step. "},{"title":"sentry:deploy:dev","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#sentrydeploydev","content":"The job runs on pushes to the master branch, and will associate the release with the deployment environment dev. "},{"title":"deploy:dev","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"cra/configuration/gitlab-ci#deploydev","content":"This is the main job for deploying to OpenShift. It runs on the master branch. It will create an Environment in GitLab, with the URL to the running app. The script has four steps: Create an app in your OpenShift project with the name dev, unless it existsStart a docker image build for that app with the output from the build jobCreate a route for that application unless it existsLabel the route with ingress-tenant=aa (more info) The route defaults to https://{projectSlug}.apps.int.intility.no. "},{"title":"Sentry","type":0,"sectionRef":"#","url":"cra/configuration/sentry","content":"","keywords":""},{"title":"Create Project","type":1,"pageTitle":"Sentry","url":"cra/configuration/sentry#create-project","content":"Head over to the Create a new Project page in Sentry.  Under platform, select React.  For the project name, use the project slug from GitLab. If you use something other than the project slug you'll need to modify the SENTRY_PROJECT variable in the top of the .gitlab-ci.yml file. Select a fitting team, or create a new one, and hit Create. You'll be taken to a Configure React page. In the code example under Connecting the SDK to Sentry, copy the dsn value, and add it to GitLab CI/CD variables with the key SENTRY_DSN. "},{"title":"Acquire Token","type":1,"pageTitle":"Sentry","url":"cra/configuration/sentry#acquire-token","content":"Go to the Auth Token section of your Account Settings. The needed scopes are project:read, project:releases and org:read. Create it, copy the token and add it to GitLab CI/CD variables with the key SENTRY_AUTH_TOKEN. "},{"title":"SonarQube","type":0,"sectionRef":"#","url":"cra/configuration/sonarqube","content":"","keywords":""},{"title":"Badge","type":1,"pageTitle":"SonarQube","url":"cra/configuration/sonarqube#badge","content":"On your project dashboard, you can click Get project badges in the bottom right corner.  Select Quality Gate Status, and Image URL only. You can then use the Image URL and project dashboard URL to create a badge in GitLab.  "},{"title":"Included Dependencies","type":0,"sectionRef":"#","url":"cra/getting-started/included-dependencies","content":"","keywords":""},{"title":"@intility/bifrost-react","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#intilitybifrost-react","content":"Docs Intility's design system for React. "},{"title":"@intility/react-msal-browser","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#intilityreact-msal-browser","content":"Docs (WIP) @intility/react-* is an abstraction of the 3 auth libraries (adal, msal, msal-browser) by Microsoft for React. "},{"title":"react-router","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#react-router","content":"Docs (v6) Unless you're a dashboard, you need a router, and react-router is the de facto router for React. "},{"title":"@sentry/react and @sentry/tracing","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#sentryreact-and-sentrytracing","content":"Docs Used for error reporting to Sentry. "},{"title":"prettier","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#prettier","content":"Docs Prettier is a code formatter and great tool for unifying formatting when collaborating on a project. The Visual Studio Code Workspace is set up to auto-format on save. "},{"title":"source-map-explorer","type":1,"pageTitle":"Included Dependencies","url":"cra/getting-started/included-dependencies#source-map-explorer","content":"GitHub See Analyzing the Bundle Size for more information. You can use it by running the following command in your project. npm run analyze Copy "},{"title":"Installation","type":0,"sectionRef":"#","url":"cra/getting-started/installation","content":"","keywords":""},{"title":"Prerequisites","type":1,"pageTitle":"Installation","url":"cra/getting-started/installation#prerequisites","content":"Some experience with Reactnode.jsVisual Studio Code with the following plugins Node Extension PackPrettier Set up the Intility NPM registry (optional) "},{"title":"Intility NPM Registry (optional)","type":1,"pageTitle":"Installation","url":"cra/getting-started/installation#intility-npm-registry-optional","content":"The Intility NPM registry (includes access to @intility/* and @fortawesome/* packages) can be configured by running: npm config set registry https://artifactory.int.intility.no/artifactory/api/npm/npm/ Copy For other alternatives, see the guide on developers.intility.no (login required). "},{"title":"Create App","type":1,"pageTitle":"Installation","url":"cra/getting-started/installation#create-app","content":"Select the version you want. By default, TypeScript and an authentication sample is included. default git branch create-react-app automatically creates a git repo. If you want the default branch to be something other than master, you need to set the init.defaultBranch config in git: git config --global init.defaultBranch main You need git version 2.28.0 or higher to use this option. TypeScriptJavaScript npx create-react-app my-app --template \"@intility\" Copy Run it in your terminal, and then open the Visual Studio Code Workspace with the following command. code my-app/app.code-workspace Copy You can now start coding by running the start script. npm start Copy "},{"title":"Available Scripts","type":1,"pageTitle":"Installation","url":"cra/getting-started/installation#available-scripts","content":"There are 5 scripts included by default, click on each one for more information. npm startnpm testnpm run buildnpm run ejectnpm run analyze "},{"title":"Project Overview","type":0,"sectionRef":"#","url":"cra/getting-started/project-overview","content":"Depending on which template you chose, your project structure will look more or less like the following: ├── public │ ├── favicon.ico │ ├── index.html │ ├── logo192.png │ ├── logo512.png │ ├── manifest.json │ └── robots.txt ├── src │ ├── assets │ │ └── logo.svg │ ├── components │ │ ├── About.tsx │ │ ├── App.css │ │ ├── App.test.tsx │ │ ├── App.tsx │ │ ├── Home.tsx │ │ └── Profile.tsx │ ├── index.tsx │ ├── react-app-env.d.ts │ ├── serviceWorker.ts │ └── setupTests.ts ├── .env.development ├── .eslintrc ├── .gitignore ├── .gitlab-ci.yml ├── .npmrc ├── Dockerfile ├── README.md ├── app.code-workspace ├── package-lock.json ├── package.json └── tsconfig.json Copy","keywords":""},{"title":"Recommended Packages","type":0,"sectionRef":"#","url":"cra/getting-started/recommended-packages","content":"","keywords":""},{"title":"react-table","type":1,"pageTitle":"Recommended Packages","url":"cra/getting-started/recommended-packages#react-table","content":"Docs Data modification for tables. Bifrost's Table component is only responsible for the view, and will not do any data modification for you. "},{"title":"swr","type":1,"pageTitle":"Recommended Packages","url":"cra/getting-started/recommended-packages#swr","content":"Docs Data Fetching library using React hooks. Makes data fetching easy, comes with a cache, Suspense support and more. "},{"title":".NET Templates","type":0,"sectionRef":"#","url":"dotnet/","content":"","keywords":""},{"title":"Recommended reading","type":1,"pageTitle":".NET Templates","url":"dotnet/#recommended-reading","content":"Tutorial: Create a web API with ASP.NET CoreASP.NET Core fundamentalsIntility Template Source "},{"title":"Adding Environments","type":0,"sectionRef":"#","url":"dotnet/advanced/adding-environments","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"ADFS Authorization","type":0,"sectionRef":"#","url":"dotnet/advanced/adfs","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"AAD Authentication","type":0,"sectionRef":"#","url":"cra/configuration/authentication","content":"","keywords":""},{"title":"UI","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#ui","content":"Head over to Azure -> Azure Active Directory -> App registrationswith your Intility Account, and create a new registration.  Select a fitting name for your project, this name will be presented to the user during consent. Under Supported account types, choose either Intility AS only - Single tenant or Any Azure AD directory - Multitenant. This can be changed later, so if you're unsure what to choose, select single tenant. Under Redirect URI, select Single-page application (SPA) from the dropdown, and enter http://localhost:3000. Hit the register button, and you will be taken to an overview of your newly created registration.  Copy the Application (Client) ID GUID, and paste it into the clientId field in your index.tsx file. src/index.tsx const msal ={ auth:{ clientId:\"YOUR_CLIENT_ID\", ... }, ... } Copy Check out Enabling authentication in your app to enable authentication in your app. "},{"title":"Adding reply URLs","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#adding-reply-urls","content":"For each deployment of your app, you'll need to register it. You can do that by going to the Authentication page.  The first we need to add is the URL the deploy step makes in OpenShift: https://{your-project-slug}-dev.apps.int.intility.no Copy You can also add more later if you create more environments. "},{"title":"CLI","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#cli","content":"Login with the Azure CLI and run the following command (rember to modify the displayName) bashPowerShell az rest -u https://graph.microsoft.com/v1.0/applications -m post -b '{\"displayName\":\"MyApp\",\"spa\":{\"redirectUris\":[\"http://localhost:3000\"]}}' Copy Copy the appId GUID, and paste it into the clientId field in your index.tsx file. src/index.tsx const msal ={ auth:{ clientId:\"YOUR_CLIENT_ID\", ... }, ... } Copy Check out Enabling authentication in your app to enable authentication in your app. "},{"title":"Enabling authentication in your app","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#enabling-authentication-in-your-app","content":"Depending on what your applications scope is, there are different ways of enabling authentication. "},{"title":"Forcing auth","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#forcing-auth","content":"This is the simplest way, and can be enabled by adding the forced prop to MsalBrowserProvider. src/index.tsx ReactDOM.render( <Router> <MsalBrowserProviderconfig={msal}forced> ^^^^^^ <React.StrictMode> <App/> </React.StrictMode> </MsalBrowserProvider> </Router>, document.getElementById(\"root\") ) Copy This will force user authentication, and your app won't render unless the user is authenticated. "},{"title":"Conditional auth","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#conditional-auth","content":"If you don't want forced auth, you can implement a simple log-in button by using the useAuth hook from @intility/react-msal-browser. import{ Button }from\"@intility/bifrost-react\"; import{ useAuth }from\"@intility/react-msal-browser\"; constLoginButton=()=>{ const{ login }=useAuth(); return( <ButtononClick={login}>Login</Button> ) }; Copy And elsewhere in your app you can determin the login status by checking the existance of a user with useUser. import{ useUser }from\"@intility/react-msal-browser\"; constMyComponent=()=>{ const user =useUser(); return<span>{user !==null?\"Hello friend.\":\"Who are you?\"}</span>; }; Copy "},{"title":"Consuming an authenticated API","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#consuming-an-authenticated-api","content":"Consuming an authenticated API is relativly simple. First, you'll need to modify the endpoints section of your MSAL config. The key needs to be the base URL of the API, and the value should be an array of scopes needed to authenticate to the API. src/index.tsx const msal ={ endpoints:{ \"http://localhost:5000\":[\"API_SCOPE\"], ... }, ... } Copy The API base URL can also be dynamically applied from an Environment Variables. TypeScriptJavaScript src/index.tsx const msal ={ endpoints:{ [process.env.REACT_APP_API_URLasstring]:[\"API_SCOPE\"], ... }, ... } Copy You can now consume an API with authorizedFetch, which uses the endpoints config to detect which token to use in a request. import{ useState, useEffect }from\"react\"; import{ authorizedFetch }from\"@intility/react-msal-browser\"; // This is a simplified example of data fetching in react // Please don't use in production constDataComponent=()=>{ const[data, setData]=useState(); const[error, setError]=useState(); useEffect(()=>{ authorizedFetch(\"my-api/resource\") .then((response)=> response.json()) .then((json)=>setData(json)) .catch((error)=>setError(error)); },[]); return( <> {!data &&!error &&<p>Loading data...</p>} {data &&<div>Here is the data:{data}</div>} {error &&<pclassName=\"error\">Oh No!!!{error.toString()}</p>} </> ); }; Copy "},{"title":"SWR / React Query","type":1,"pageTitle":"AAD Authentication","url":"cra/configuration/authentication#swr--react-query","content":"SWRReact Query Integrating authenticatedFetch with SWR is very simple. All you need to do is specify a fetcher for SWR. TypeScriptJavaScript import useSWR from\"swr\"; import{ authorizedFetch }from\"@intility/react-msal-browser\"; constauthFetcher=(url: string)=> authorizedFetch(url).then((result)=> result.json()); constSwrComponent=()=>{ const{ data, error }=useSWR(\"my-api/resource\",{ fetcher: authFetcher }); return( <> {!data &&!error &&<p>Loading data...</p>} {data &&<div>Hereis the data:{data}</div>} {error &&<pclassName=\"error\">OhNo!!!{error.toString()}</p>} </> ); }; Copy We could take this one step further, and assign the fetcher globally using SWRConfig. TypeScriptJavaScript src/index.tsx import{SWRConfig}from\"swr\"; import{ authorizedFetch }from\"@intility/react-msal-browser\"; // Note that we apply a base url to every request const swr ={ fetcher:(path: string)=> authorizedFetch((process.env.REACT_APP_API_URLasstring)+ path) .then(response=> response.json()) }; ReactDOM.render( <Router> <MsalBrowserProviderconfig={msal}forced> <SWRConfigvalue={swr}> <React.StrictMode> <App/> </React.StrictMode> </SWRConfig> </MsalBrowserProvider> </Router>, document.getElementById(\"root\") ); Copy We can now call useSWR somewhere in our app, and it will by default use the authorized fetcher. import useSWR from\"swr\"; import{ authorizedFetch }from\"@intility/react-msal-browser\"; constSwrComponent=()=>{ // Note that only the resource is requested here // that's because the API base URL is prepended in our fetcher const{ data, error }=useSWR(\"resource\"); return( <> {!data &&!error &&<p>Loading data...</p>} {data &&<div>Here is the data:{data}</div>} {error &&<pclassName=\"error\">Oh No!!!{error.toString()}</p>} </> ); }; Copy One great thing about SWR is request deduping and caching. In the following example, there will be three instances of our SwrComponent, but only one request will be made. That would not be the case if we were to use the DataComponent from earlier, where we manually fetched the data. constSomeExample=()=>( <> <SwrComponent/> <SwrComponent/> <SwrComponent/> </> ); Copy To read more about SWR, check out the SWR Docs. "},{"title":"Deploy with ArgoCD","type":0,"sectionRef":"#","url":"dotnet/advanced/deploy-argocd","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"Logging to Elastic","type":0,"sectionRef":"#","url":"dotnet/advanced/elastic","content":"","keywords":""},{"title":"Deploy to Azure","type":0,"sectionRef":"#","url":"dotnet/advanced/deploy-azure","content":"info This page isn't finished yet. If you are comfortable with this subject, feel free to contibute.","keywords":""},{"title":"Features","type":0,"sectionRef":"#","url":"dotnet/features","content":"The template is packed with already made decisions, so you don't have to make them. These solutions are a culmination of many years of managing services in production and aims to target established in-house infrastructure. note The templates are updated as the technology and infrastructure changes over time. Helm chartProject debug settingsSwagger configurationDockerfilesREADME templateGitLab CI/CD pipelineAPI VersioningLogging configurationTelemetry instrumentation","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"dotnet/installation","content":"","keywords":""},{"title":"Bootstrap new project using the template","type":1,"pageTitle":"Installation","url":"dotnet/installation#bootstrap-new-project-using-the-template","content":"You can either use the dotnet new command or Visual Studio -> New Project wizard to create a new project based on the templates. dotnet CLIVisual Studio # create project dotnet new iwebapi -o MyService # run project cd MyService dotnet run --project MyService/MyService.csproj Copy "},{"title":"Updating the template","type":1,"pageTitle":"Installation","url":"dotnet/installation#updating-the-template","content":"warning Earlier versions of the CLI had troubles updating packages due to long-lived caches. You need to be on version 5.0.301 or higher for updating to work properly. note This will not update already bootstrapped projects. Check for updates by running dotnet new --update-check Copy If there are any updates available, update with dotnet new --update-apply Copy or dotnet new --install Intility.Templates Copy "},{"title":"AAD Authorization","type":0,"sectionRef":"#","url":"dotnet/setup/authorization","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"AAD Authorization","url":"dotnet/setup/authorization#api","content":"Head over to Azure -> Azure Active Directory -> App registrationswith your Intility Account, and create a new registration.  Select a fitting name for your project, this name will be presented to the user during consent. Under Supported account types, choose either Intility AS only - Single tenant or Any Azure AD directory - Multitenant. This can be changed later, so if you're unsure what to choose, select single tenant. Under Redirect URI, select Web from the dropdown, and enter http://localhost:5000. Hit the register button, and you will be taken to an overview of your newly created registration.  Copy the Application (Client) ID GUID, and paste it into the AzureAd:ClientId field in your appsettings.json file. appsettings.json { \"AzureAd\":{ \"ClientId\":\"YOUR_CLIENT_ID\", ... }, ... } Copy "},{"title":"Add an application scope","type":1,"pageTitle":"AAD Authorization","url":"dotnet/setup/authorization#add-an-application-scope","content":"Go to Expose an API in your app registration, and add a scope. You will be prompted to set an Application ID URI. Use the suggested one, and hit Save and continue.  Add a scope named user_impersonation, that can be consented by Admins and users. You can use the following descriptions: Access API as user Allows the app to access the API as the user. Access API as you Allows the app to acces the API as you. Copy "},{"title":"Swagger","type":1,"pageTitle":"AAD Authorization","url":"dotnet/setup/authorization#swagger","content":"In addition to creating an App Registration for the API itself, we need to make one for the Swagger client too. Again head over to Azure -> Azure Active Directory -> App registrations.  Use the same name appended with Swagger. Under Redirect URI, select Single-page application (SPA) and enter http://localhost:5000/oauth2-redirect.html. Hit the register button, and you will be taken to an overview of your newly created registration.  Copy the Application (Client) ID GUID, and paste it into the AzureAd:ClientId field in your appsettings.json file. appsettings.json { \"Swagger\":{ \"ClientId\":\"YOUR_SWAGGER_CLIENT_ID\", ... }, ... } Copy "},{"title":"Adding reply URLs","type":1,"pageTitle":"AAD Authorization","url":"dotnet/setup/authorization#adding-reply-urls","content":"For each deployment of your app, you'll need to register it. You can do that by going to the Authentication page.  The first reply URLs we need to add are the localhost https URL, and the OpenShift deploy URL: https://localhost:5001/oauth2-redirect.html https://{your-project-slug}-dev.apps.int.intility.no/oauth2-redirect.html Copy You can also add more later if you create more environments. "},{"title":"Access API","type":1,"pageTitle":"AAD Authorization","url":"dotnet/setup/authorization#access-api","content":"To allow Swagger to talk to the API, you need to add API permissions to the Swagger app registration. Go to API permissions, and hit Add a permission. Under My APIs, find your API, select the scope(s) and press Add permissions.  "},{"title":"Deploy","type":0,"sectionRef":"#","url":"dotnet/setup/deploy","content":"","keywords":""},{"title":"Create project","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#create-project","content":""},{"title":"UI","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#ui","content":"Go to our OpenShift instance and log in as Intility Developer. Create a project, the name should be aa-<GITLAB_SLUG>-dev, e.g. aa-my-app-dev. If you use something other than this, you'll need to modify the OPENSHIFT_PROJECT variable in the top of the .gitlab-ci.yml file. Add a fitting display name and description if you feel like it. "},{"title":"CLI","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#cli","content":"The name should be aa-<GITLAB_SLUG>-dev, e.g. aa-my-app-dev. If you use something other than this, you'll need to modify the OPENSHIFT_PROJECT variable in the top of the .gitlab-ci.yml file. oc new-project <projectname> Copy "},{"title":"Acquire Token","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#acquire-token","content":""},{"title":"UI","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#ui-1","content":"In your newly created project, switch from Developer to Administrator view in the sidebar. Then go to User Management -> Service Accounts, and click Create Service Account. Change the name field to gitlab-builder.  After creating the Service Account, go to User Mangement -> Role Bindings, and click Create Binding. Fill the form with the following values: Role Binding Name: gitlab-builder-edit Role Name: edit Subject: Service Account Subject Name: gitlab-builder  After creating the role binding, go back to Service Accounts and go to the gitlab-builder Service Account. At the bottom of page, you'll find a link to a secret named gitlab-builder-token-*, click it. Copy the token field at the bottom of the page, and add it to GitLab CI/CD variables with the key OPENSHIFT_TOKEN. "},{"title":"CLI","type":1,"pageTitle":"Deploy","url":"dotnet/setup/deploy#cli-1","content":"Copy login command from OpenShift Console and paste it in a terminal. After logging in, the CLI will show you available projects. Follow the instructions to change to the project you just created. When you have selected the right project, we need to create a Service Account. oc create sa gitlab-builder oc describe sa gitlab-builder Copy Note the gitlab-builder-token-* in the Mountable secrets section. Then we have to set the user to admin. oc policy add-role-to-user edit -z gitlab-builder Copy Lastly, we have to extract the token from the secret presented in the first step. oc describe secret <secret-name> Copy Copy the contents from the token section and add it to GitLab CI/CD variables with the key OPENSHIFT_TOKEN. "},{"title":".gitlab-ci.yml Overview","type":0,"sectionRef":"#","url":"dotnet/setup/gitlab-ci","content":"","keywords":""},{"title":"Jobs","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#jobs","content":""},{"title":"build","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#build","content":"Builds the project, and creates a build artifact for later stages to use. "},{"title":"test","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#test","content":"Runs the tests in the project. Runs parallel with build. "},{"title":"analyze","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#analyze","content":"Analyzes the project with sonar-scanner. Runs parallel with build. "},{"title":"image:dev","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#imagedev","content":"Uses the artifact from the build step, and creates and publish a docker image with the Dockerfile.CI file using kaniko. Runs once the build job has finished, and only in the master or main branch. "},{"title":"deploy:dev","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#deploydev","content":"Deploys the application to OpenShift using the Helm chart. Runs once the image:dev and test jobs have succeeded, and only in the master or main branch. "},{"title":"Debugging the pipeline","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#debugging-the-pipeline","content":""},{"title":"Paths","type":1,"pageTitle":".gitlab-ci.yml Overview","url":"dotnet/setup/gitlab-ci#paths","content":"Ensure the paths used are right. In the build step, we need to ensure that we are working from the right folder. .gitlab-ci.yml build: script: - dotnet restore - cd YOUR_PROJECT_FOLDER # cd to the project folder - dotnet publish -o build artifacts: paths: - YOUR_PROJECT_FOLDER/build # the build in the project folder Copy In image:dev, we need the context parameter to be set to the project folder. .gitlab-ci.yml image:dev: script: - echo ... - /kaniko/executor --context $CI_PROJECT_DIR/YOUR_PROJECT_FOLDER # sets the context to your project folder Copy In deploy:dev, ensure the path to the chart is right. .gitlab-ci.yml deploy:dev: script: - oc login $OPENSHIFT_SERVER --token=$OPENSHIFT_TOKEN - helm upgrade --install $CI_ENVIRONMENT_SLUG ./YOUR_PROJECT_FOLDER/chart # path to chart Copy "},{"title":"GitLab Repository","type":0,"sectionRef":"#","url":"dotnet/setup/gitlab","content":"","keywords":""},{"title":"Pushing your application","type":1,"pageTitle":"GitLab Repository","url":"dotnet/setup/gitlab#pushing-your-application","content":"Create React App creates a git repository for you locally, but you'll have to add the GitLab repository as a remote. Follow the \"Push an existing folder\" example. They should look something like this: git init git remote add origin git@gitlab.intility.no:Group/intility-api.git gitadd. git commit -m \"Initial commit\" git push -u origin master Copy The pipeline will fail initially, but don't worry, we'll set it up correctly in the next steps. "},{"title":"Add GitLab Deploy Token","type":1,"pageTitle":"GitLab Repository","url":"dotnet/setup/gitlab#add-gitlab-deploy-token","content":"The pipeline publishes a docker image to GitLab Container Registry, and uses Helm to create resources in OpenShift. As a result, OpenShift needs access to pull images from GCR. In your GitLab repository, go to Settings -> Repository -> Deploy tokens. Create a new token named gitlab-deploy-token, and give it the read_registry scope.  That's all you have to do in the repository. The token is exposed as a variable in the pipeline, and helm applies it as a pull secret in OpenShift. Read more about GitLab deploy tokens here. "},{"title":"Adding CI/CD Variables","type":1,"pageTitle":"GitLab Repository","url":"dotnet/setup/gitlab#adding-cicd-variables","content":"In your project on GitLab, go to Settings -> CI / CD, and expand the Variables section. We don't need to add anything yet, but it's here we'll add tokens and such in the other steps. "},{"title":"Adding Badges","type":1,"pageTitle":"GitLab Repository","url":"dotnet/setup/gitlab#adding-badges","content":"In your project on GitLab, go to Settings -> General, and expand the Badges section. Here you can add badges by giving them a Name, Link and Image URL.  We can go ahead and add a badge for our pipeline with the following values: Name: Pipeline Link: https://gitlab.intility.com/%{project_path} Image URL: https://gitlab.intility.com/%{project_path}/badges/%{default_branch}/pipeline.svg "},{"title":"SonarQube","type":0,"sectionRef":"#","url":"dotnet/setup/sonarqube","content":"","keywords":""},{"title":"Badge","type":1,"pageTitle":"SonarQube","url":"dotnet/setup/sonarqube#badge","content":"On your project dashboard, you can click Get project badges in the bottom right corner.  Select Quality Gate Status, and Image URL only. You can then use the Image URL and project dashboard URL to create a badge in GitLab.  "},{"title":"Sentry","type":0,"sectionRef":"#","url":"dotnet/setup/sentry","content":"","keywords":""},{"title":"Create Project","type":1,"pageTitle":"Sentry","url":"dotnet/setup/sentry#create-project","content":"Head over to the Create a new Project page in Sentry.  Under platform, select .NET.  For the project name, use the project slug from GitLab. If you use something other than the project slug you'll need to modify the SENTRY_PROJECT variable in the top of the .gitlab-ci.yml file. Select a fitting team, or create a new one, and hit Create. You'll be taken to a Configure .NET page. In the code examples, copy the DSN value passed to Sentry.Init, and add it to GitLab CI/CD variables with the key SENTRY_DSN. "},{"title":"Configuration","type":0,"sectionRef":"#","url":"dotnet/topics/configuration","content":"","keywords":""},{"title":"Azure AD Authentication","type":1,"pageTitle":"Configuration","url":"dotnet/topics/configuration#azure-ad-authentication","content":" ⚠️ TODO: App RegistrationsThe relationship between SPA App, Resource App How to configure them properly  { \"AzureAd\":{ // azure identity platform instance (should not be changed) \"Instance\":\"https://login.microsoftonline.com/\", // primary domain of your tenant \"Domain\":\"intility.onmicrosoft.com\", // tenant / directory id \"TenantId\":\"9b5ff18e-53c0-45a2-8bc2-9c0c8f60b2c6\", // client id of your azure appReg \"ClientId\":\"11111111-1111-1111-11111111111111111\" } } Copy "},{"title":"Swagger","type":1,"pageTitle":"Configuration","url":"dotnet/topics/configuration#swagger","content":" ⚠️ TODO: Swagger authenticationSwagger versioning relationship with API versioning  { \"Swagger\":{ // Name of the service in Swagger definition and UI \"AppName\":\"Company.WebApplication1 Swagger\", // The client id to authenticate with. This should be an // app registration with delegated permission to the API registration \"ClientId\":\"22222222-2222-2222-22222222222222222\" } } Copy "},{"title":"Logging","type":1,"pageTitle":"Configuration","url":"dotnet/topics/configuration#logging","content":"Logging is provided by the external package Intility.Logging.AspNetCore in conjunction with logger sink extensions. The goal with the external package is to enable continuous development of logging support centrally, as the infrastructure changes over time, alleviating you of this burden. note For more information about logging configurations visit the Logging section. { \"Serilog\":{ \"MinimumLevel\":{ \"Default\":\"Information\", \"Override\":{ \"System\":\"Warning\", \"Microsoft\":\"Warning\", \"Microsoft.Hosting.Lifetime\":\"Information\" } }, \"Properties\":{ \"Application\":\"MyService\" } } } Copy "},{"title":"API Versioning","type":0,"sectionRef":"#","url":"dotnet/topics/versioning","content":"","keywords":""},{"title":"Logging","type":0,"sectionRef":"#","url":"dotnet/topics/logging","content":"","keywords":""},{"title":"Creating Logs","type":1,"pageTitle":"Logging","url":"dotnet/topics/logging#creating-logs","content":"To create logs, use an ILogger<TCategoryName> object from dependency injection (DI). Let's take a look at the following example: [ApiController] [Route(\"[controller]\")] public class CustomerController : ControllerBase { private readonly ILogger _logger; public CustomerController(ILogger<CustomerController> logger) { _logger = logger; } [HttpPost] public ActionResult<Customer> Create(CreateCustomerDTO createCustomerDto) { _logger.LogInformation( \"Customer endpoint called at {Timestamp}\", DateTime.UtcNow.ToLongTimeString()); //... } } Copy The DI system creates a logger and injects it into the controller. In this example the logger uses a log category of the fully qualified name of the type CustomerController. The log category is a string that is associated with each log entry and makes it easier to troubleshoot large quantities of logs. One can also observe that we are logging with the LogInformation extension method. Information is one of several log levels available - ordered by criticality: Debug:General debug information used in development environments with high verbosity Trace: Events related to code performance and infrastructure Information:Low criticality application information Warning:Medium criticality information and recoverable exceptions Error:Hight criticality information about non-recoverable exceptions and faulty states Critical:Severely critical messages related to crashes where the process cannot recover "},{"title":"Structured Logging","type":1,"pageTitle":"Logging","url":"dotnet/topics/logging#structured-logging","content":"In addition to the message we are also taking advantage of the structured logging capabilities baked into the logger. This means that we can inject arbitrary metadata surrounding our log events to make troubleshooting even easier. In the example above we are injecting the current timestamp into a property called Timestamp. Further more, we can also pass inn serializable objects like reference types or records. Serilog will automatically serialize the properties for you. Note that you have to prefix your property name with an @ symbol for this serialization to take place var albert = new { Name = \"Albert Aaberg\" }; logger.LogWarning(\"Could not find any friends of {@User}\", albert); Copy "},{"title":"Scoping","type":1,"pageTitle":"Logging","url":"dotnet/topics/logging#scoping","content":"It is sometimes useful to attach common metadata to a series of log events in your application instead of placing them separately in the log message itself. var props = new Dictionary<string,object>() { { \"Name\", \"Albert Aaberg\"}, { \"Friends\", 0 } }; using(logger.BeginScope(props)) { logger.LogInformation(\"Every log message inside this scope has metadata attached\"); } logger.LogInformation(\"The props has left the building\"); Copy  "},{"title":"Configure Logging","type":1,"pageTitle":"Logging","url":"dotnet/topics/logging#configure-logging","content":"With the serilog configuration it is possible to override the verbosity of the logs for each namespace separately. Very useful if you need to up the verbosity of your own code without clutter. NB: The overrides should always be stricter than the default MinimumLevel. There is also a very handy Properties section that lets you define custom metadata surrounding all your log events. The application host can also inject additional context to your logs through environment variables through the same configuration infrastructure. Configuration is usually provided by the Serilog section of the appsettings.{Environment}.json files. The following appsettings.json file is generated by the template. { \"Serilog\":{ \"MinimumLevel\":{ \"Default\":\"Information\", \"Override\":{ \"System\":\"Warning\", \"Microsoft\":\"Warning\", \"Microsoft.Hosting.Lifetime\":\"Error\" } }, \"Properties\":{ \"Application\":\"MyService\" } } Copy You can read more about logging at the official .NET Core documentation and by visiting the Serilog documentation for a complete overview of the configuration capabilities. Logging in .NET Core and ASP.NET Core~55 minutes to read "}]