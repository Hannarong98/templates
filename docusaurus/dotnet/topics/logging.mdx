---
title: Logging
sidebar_position: 2
---

Logging is provided by the external package `Intility.Logging.AspNetCore` in conjunction with logger sink extensions. 
The goal with the external packages is to enable continuous development of logging support centrally, 
as the infrastructure changes over time, alleviating you of this burden. The packages are realying heavily on the 
logging infrastructure provided by the dotnet runtime.

:::note
Logging packages are maintained at [github.com/intility/intility.logging](https://github.com/Intility/Intility.Logging)
:::

## Creating Logs

To create logs, use an `ILogger<TCategoryName>` object from dependency injection (DI).

Let's take a look at the following example:

```csharp
[ApiController]
[Route("[controller]")]
public class CustomerController : ControllerBase
{
    private readonly ILogger _logger;

    public CustomerController(ILogger<CustomerController> logger)
    {
        _logger = logger;
    }

    [HttpPost]
    public ActionResult<Customer> Create(CreateCustomerDTO createCustomerDto)
    {
        _logger.LogInformation(
            "Customer endpoint called at {Timestamp}", 
            DateTime.UtcNow.ToLongTimeString());

        //...
    }
}
```

export const Highlight = ({children, bg, title}) => (
  <div
    style={{
      padding: '0.5rem',
      borderLeft: '10px solid ' + bg,
      margin: '0'
    }}>
    <span style={{paddingRight: '.2rem'}}><strong>{title}</strong>:</span>
    {children}
  </div>
);

The DI system creates a logger and injects it into the controller. In this example the logger uses a log 
category of the fully qualified name of the type `CustomerController`. The log category is a string that 
is associated with each log entry and makes it easier to troubleshoot large quantities of logs.

One can also observe that we are logging with the `LogInformation` extension method. `Information` is one of 
several log levels available - ordered by criticality:

<div style={{marginBottom: '1rem'}}>
    <Highlight bg="#f0f0f0" title="Debug">General debug information used in development environments with high verbosity</Highlight>
    <Highlight bg="#ccc" title="Trace"> Events related to code performance and infrastructure</Highlight>
    <Highlight bg="var(--ifm-color-info)" title="Information">Low criticality application information</Highlight>
    <Highlight bg="var(--ifm-color-warning)" title="Warning">Medium criticality information and recoverable exceptions</Highlight>
    <Highlight bg="var(--ifm-color-danger)" title="Error">Hight criticality information about non-recoverable exceptions and faulty states</Highlight>
    <Highlight bg="var(--ifm-color-danger-darkest)" title="Critical">Severely critical messages related to crashes where the process cannot recover</Highlight>
</div>

## Structured Logging

In addition to the message we are also taking advantage of the structured logging capabilities baked into the logger. This means 
that we can inject arbitrary metadata surrounding our log events to make troubleshooting even easier. In the example above we are 
injecting the current timestamp into a property called `Timestamp`. 

Further more, we can also pass inn serializable objects like reference types or records. Serilog will automatically serialize the 
properties for you. Note that you have to prefix your property name with an `@` symbol for this serialization to take place

```csharp
var albert = new { Name = "Albert Aaberg" };
logger.LogWarning("Could not find any friends of {@User}", albert);
```

## Scoping

It is sometimes useful to attach common metadata to a series of log events in your application instead of placing them separately 
in the log message itself.

```csharp
var props = new Dictionary<string,object>()
{
    { "Name", "Albert Aaberg"},
    { "Friends", 0 }
};

using(logger.BeginScope(props))
{
    logger.LogInformation("Every log message inside this scope has metadata attached");
}

logger.LogInformation("The props has left the building");
```

<img src="/img/logging-scoped-props.png" alt="scoped props result" />

## Configure Logging

With the serilog configuration it is possible to override the verbosity of the logs for each namespace separately. 
Very useful if you need to up the verbosity of your own code without clutter. 

**NB: The overrides should always be stricter than the default MinimumLevel.**

There is also a very handy `Properties` section that lets you define custom metadata surrounding all your log events. 
The application host can also inject additional context to your logs through environment variables through the same 
configuration infrastructure.

Configuration is usually provided by the Serilog section of the `appsettings.{Environment}.json` files.
The following appsettings.json file is generated by the template.

```json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "System": "Warning",
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Error"
      }
    },
    "Properties": {
        "Application": "MyService"
    }
}
```

You can read more about logging at the official .NET Core documentation and by visiting the [Serilog documentation](https://github.com/serilog/serilog-settings-configuration) for a complete overview of the configuration capabilities.

import MsDocsCard from '../../src/components/MsDocsCard.js';

<div style={{marginBottom: '20px'}}>
<MsDocsCard 
    width="380px" 
    title="Logging in .NET Core and ASP.NET Core" 
    subtitle="~55 minutes to read" 
    url="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0" />
</div>
